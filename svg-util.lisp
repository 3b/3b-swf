(defpackage :svg-swf
  (:export
   #:import-from-svg)
  (:use :common-lisp :3b-swf))

(in-package :svg-swf)

(defparameter *indent* 0)
(defvar *defs*)

(defun indent ()
  (fresh-line *trace-output*)
  (loop repeat *indent* do (write-char #\Space *trace-output*)))


(defun style-attribute-string (element name)
  (let* ((style-string (dom:get-attribute element "style"))
         (style-parts (mapcar (lambda (x)
                                (split-sequence:split-sequence #\: x))
                              (split-sequence:split-sequence #\; style-string)))
         (string (second (find name style-parts :key 'first :test 'string=))))
    string))

(defun attribute (element name &optional default (parser #'identity) inherit)
  (let ((string (dom:get-attribute element name)))
    (when (zerop (length string))
      (setf string (style-attribute-string element name)))
    #+nil(when (and (Zerop (length string)) inherit)
      (format t "checking inherited property ~s from node ~s, parent = ~s~%"
              name element (dom:parent-node element))
      (if (and inherit (dom:parent-node element)
               (dom:element-p (dom:parent-node element)))
          (format t "got ~s~%" (attribute (dom:parent-node element) name default parser inherit))
          (format t "defaulted to ~s~%" default)))
    (if (zerop (length string))
        (if (and inherit (dom:parent-node element)
                 (dom:element-p (dom:parent-node element)))
            (attribute (dom:parent-node element) name default parser inherit)
            default)
        (funcall parser string))))


(defun default-to (x default) (if (eql x :default) default x))

(defun parse-paint (string)
  ;;(format t "parse-paint ~s~%" string)
  (unless string (return-from parse-paint :default))
  (setf string (trim string))
  (cond ((string-equal string "none") :none)
        ;;((string-equal string "currentcolor") :default) ; XXX
        ((eql 4 (mismatch string "url("))
         (let* ((url (subseq string 4 (position #\) string)))
                (val (when (and (> (length url) 1)
                                 (char= #\# (aref url 0)))
                        (gethash (subseq url 1) *defs*))))
           ;;(format t "url paint ~s =~% [[~s]]~%" string val)
           val))
        (t (parse-color string))))

(defun parse-blur-dev (string)
  (with-input-from-string (s string)
    (let ((d1 (parse-float s))
          (d2 (progn (token s #'whitespace-p)
                     (when (peek-char t s nil)
                       (parse-float s)))))
      (list d1 (or d2 d1)))
    #+nil(multiple-value-bind (d1 pos) (parse-integer string :junk-allowed t)
      (let ((d2 (parse-integer string :junk-allowed t :start pos)))
        (format t "blur dev = ~s,~s~%" d1 d2)
        (list d1 (or d2 d1))))))

(defun parse-filter-op (node)
  (let ((name (dom:tag-name node))
        (in (attribute node "in" "SourceGraphic"))
        #++(result (attribute node "result")))
    (labels ((tag (tag-name) (string-equal name tag-name)))
      (cond
        ((tag "feGaussianBlur")
         (cond
           ((string= in "SourceGraphic")
            `(:blur :dev ,(attribute node "stdDeviation" nil #'parse-blur-dev)))
           ((string= in "SourceAlpha")
            `(:glow :dev ,(attribute node "stdDeviation" nil #'parse-blur-dev)))))
        (t (error "unsupported filter op ~s" name))))))

(defun expand-filter (node)
  (format t "got filter ~s~%" node)
  (let ((ops nil))
    (dom:do-node-list (node (dom:child-nodes node))
      (when (dom:element-p node)
        (push (parse-filter-op node) ops)))
    (nreverse ops)))

(defun parse-filter (string)
  (unless string (return-from parse-filter nil))
  (setf string (trim string))
  (cond ((string-equal string "none") nil)
        ((eql 4 (mismatch string "url("))
         (let* ((url (subseq string 4 (position #\) string)))
                (val (when (and (> (length url) 1)
                                (char= #\# (aref url 0)))
                       (gethash (subseq url 1) *defs*))))
           (expand-filter val)))
        (t (warn "unknown filter value ~s" string) nil)))

(defun trim (string)
  (string-trim '(#\Space #\Tab #\Newline #\Return) string))

(defun parse-poly-points (string)
  (with-input-from-string (in string)
    (loop while (peek-char t in nil)
          do (token in #'whitespace-p)
          collect (coord (parse-float in)
                         (progn (token in #'comma-whitespace-p)
                                (parse-float in))))))

(defun attribute-token (stream)
  (token stream #'whitespace-p)
  (token stream (lambda (char)
                  (or (alphanumericp char)
                      (char= char #\#)))))

;;; Coordinates

(defstruct coord x y)
(defun coord (x y) (make-coord :x x :y y))

(defun coord-neg (coord)
  (coord (- (coord-x coord))
         (- (coord-y coord))))

(defun coord-scale (coord scale)
  (coord (* scale (coord-x coord))
         (* scale (coord-y coord))))

(defun coord+ (a b)
  (coord (+ (coord-x a) (coord-x b))
         (+ (coord-y a) (coord-y b))))

(defun coord- (a b)
  (coord (- (coord-x a) (coord-x b))
         (- (coord-y a) (coord-y b))))

(defun coord-reflect (point about)
  (coord- about (coord- point about)))

(defun coord-interp (c1 c2 param)
  (coord+ (coord-scale c1 (- 1.0 param))
          (coord-scale c2 param)))

(defun coord-normsq (c)
  (+ (* (coord-x c) (coord-x c))
     (* (coord-y c) (coord-y c))))

;;; Parsing nonsense

(defun whitespace-p (char)
  (or (char= char #\Space)
      (char= char #\Newline)
      (char= char #\Return)
      (char= char #\Tab)))

(defun comma-whitespace-p (char)
  (or (whitespace-p char)
      (char= char #\,)))

(defun token (stream accept-fn)
  "Read from stream, returning a string containing all the characters satisfying ACCEPT-FN"
  (loop with result = (make-array 0 :element-type 'character :adjustable t :fill-pointer 0)
        while (and (peek-char nil stream nil)
                   (funcall accept-fn (peek-char nil stream)))
        do (vector-push-extend (read-char stream) result)
        finally (return result)))

(defun unsigned-integer-token (stream &optional (default 0))
  "Read a sequences of digits from the stream, returning their value
   as an integer and the length in characters of the string before
   parsing. If an integer cannot be read, returns 'default' and nil."
  (let ((token (token stream #'digit-char-p)))
    (if (zerop (length token))
        (values default nil)
        (values (parse-integer token) (length token)))))

(defun integer-token (stream &optional (default 0))
  "Parse an integer from the stream, returning its value and the
length in characters of the numeric portion before parsing (not
including a minus sign). If an integer cannot be read, returns
'default' and nil."
  (cond
    ((equal #\- (peek-char t stream))
     (read-char stream)
     (multiple-value-bind (val len) (unsigned-integer-token stream default)
       (values (- val) len)))
    (t (unsigned-integer-token stream default))))

(defun parse-float (stream)
  "Parse a floating point number from a stream."
  ;; Shouldn't I make this conform to parse-float, aside from the
  ;; ability to operate on a stream?
  (when (stringp stream)
    (setf stream (make-string-input-stream stream)))
  (let ((scale 1))
    (when (equal #\- (peek-char t stream))
      (read-char stream)
      (setf scale -1))
    (multiple-value-bind (value ilen) (unsigned-integer-token stream)
      (when (equal #\. (peek-char nil stream nil))
        (read-char stream)
        (multiple-value-bind (val len) (unsigned-integer-token stream)
          (unless (or ilen len)
            (error 'parse-error))
          (incf value (/ val (expt 10 (or len 0))))))
      (when (equalp #\e (peek-char nil stream nil))
        (read-char stream)
        (multiple-value-bind (exponent explen) (integer-token stream)
          (if explen
              (setf value (* value (expt 10 exponent)))
              (error 'parse-error))))
      (* scale value 1.0))))

;;; Test parse-float:
(loop for string in '("0" "0.0" "00.000" "721.321" "1" "10" "1000"
                      "1." "10." "1000." "12.3" "12.345" "1e20" ".3e21" "7.e12"
                      "0e-1" "3e-5" "2.6e-09" "4.e-12")
      as neg = (concatenate 'string "-" string)
      do
      (assert (= (read-from-string string)
                    (parse-float (make-string-input-stream string))))
      (assert (= (read-from-string neg)
                 (parse-float (make-string-input-stream neg)))))

;;; Path strings

(defstruct smooth to control-2)
(defstruct (curve (:include smooth)) control-1)
(defstruct qcurve to control)
(defstruct elliptical-arc radii x-rot large-flag sweep-flag to)

(defun parse-path-expression (string)
  "Parse SVG PATH data, returning a list of <whatever>"
  (with-input-from-string (in string)
    (labels ((delim ()
               (loop as char = (peek-char t in nil)
                     while (and char (comma-whitespace-p char))
                     do (read-char in)))
             (cmd-char () (delim) (read-char in))
             (number () (delim) (parse-float in))
             (coord ()
               (make-coord :x (number)
                           :y (number)))
             (next-command? ()
               (delim)
               (and (peek-char t in nil)
                    (alpha-char-p (peek-char t in nil))))
             (eof? () (not (peek-char nil in nil)))
             (continue? ()
               (and (not (next-command?))
                    (not (eof?))))
             ([]+ (fn)
               (loop for n upfrom 0
                     while (continue?)
                     collect (funcall fn) into res
                     finally (if (zerop n)
                                 (error 'parse-error)
                                 (return res))))
             (smooth ()
               (make-smooth :control-2 (coord)
                            :to (coord)))
             (curve ()
               (make-curve :control-1 (coord)
                           :control-2 (coord)
                           :to (coord)))
             (qcurve ()
               (make-qcurve :control (coord)
                            :to (coord)))
             (flag ()
               (delim)
               (ecase (read-char in)
                 (#\0 nil)
                 (#\1 t)))
             (arc ()
               (make-elliptical-arc :radii (coord)
                                    :x-rot (number)
                                    :large-flag (flag)
                                    :sweep-flag (flag)
                                    :to (coord))))
      (loop while (next-command?) collect
        (ecase (cmd-char)
          ;; Basic paths
          (#\M (list* :moveto         ([]+ #'coord)))
          (#\m (list* :rel-moveto     ([]+ #'coord)))
          ((#\Z #\z) '(:close-path t))
          (#\L (list* :lineto         ([]+ #'coord)))
          (#\l (list* :rel-lineto     ([]+ #'coord)))
          (#\H (list* :horizontal     ([]+ #'number)))
          (#\h (list* :rel-horizontal ([]+ #'number)))
          (#\V (list* :vertical       ([]+ #'number)))
          (#\v (list* :rel-vertical   ([]+ #'number)))
          ;; Cubic BÃ©zier
          (#\C (list* :curveto        ([]+ #'curve)))
          (#\c (list* :rel-curveto    ([]+ #'curve)))
          (#\S (list* :smoothto       ([]+ #'smooth)))
          (#\s (list* :rel-smoothto   ([]+ #'smooth)))
          ;; Quadratic BÃ©zier
          (#\Q (list* :qcurveto       ([]+ #'qcurve)))
          (#\q (list* :rel-qcurveto   ([]+ #'qcurve)))
          (#\T (list* :qsmooth        ([]+ #'coord)))
          (#\t (list* :rel-qsmooth    ([]+ #'coord)))
          ;; Elliptical arcs
          (#\A (list* :arc     ([]+ #'arc)))
          (#\a (list* :rel-arc ([]+ #'arc))))))))

(defun for-each-path-segment (data fn)
  "Apply FN to each segment of the parsed path data produced by
parse-path-expression"
  (loop for (type . segments) in data do
        (dolist (segment segments)
          (funcall fn type segment))))

(defparameter *svg-colors*
  '(("aliceblue" . (240 248 255))
    ("antiquewhite" . (250 235 215))
    ("aqua" . (0 255 255))
    ("aquamarine" . (127 255 212))
    ("azure" . (240 255 255))
    ("beige" . (245 245 220))
    ("bisque" . (255 228 196))
    ("black" . (0 0 0))
    ("blanchedalmond" . (255 235 205))
    ("blue" . (0 0 255))
    ("blueviolet" . (138 43 226))
    ("brown" . (165 42 42))
    ("burlywood" . (222 184 135))
    ("cadetblue" . (95 158 160))
    ("chartreuse" . (127 255 0))
    ("chocolate" . (210 105 30))
    ("coral" . (255 127 80))
    ("cornflowerblue" . (100 149 237))
    ("cornsilk" . (255 248 220))
    ("crimson" . (220 20 60))
    ("cyan" . (0 255 255))
    ("darkblue" . (0 0 139))
    ("darkcyan" . (0 139 139))
    ("darkgoldenrod" . (184 134 11))
    ("darkgray" . (169 169 169))
    ("darkgreen" . (0 100 0))
    ("darkgrey" . (169 169 169))
    ("darkkhaki" . (189 183 107))
    ("darkmagenta" . (139 0 139))
    ("darkolivegreen" . (85 107 47))
    ("darkorange" . (255 140 0))
    ("darkorchid" . (153 50 204))
    ("darkred" . (139 0 0))
    ("darksalmon" . (233 150 122))
    ("darkseagreen" . (143 188 143))
    ("darkslateblue" . (72 61 139))
    ("darkslategray" . (47 79 79))
    ("darkslategrey" . (47 79 79))
    ("darkturquoise" . (0 206 209))
    ("darkviolet" . (148 0 211))
    ("deeppink" . (255 20 147))
    ("deepskyblue" . (0 191 255))
    ("dimgray" . (105 105 105))
    ("dimgrey" . (105 105 105))
    ("dodgerblue" . (30 144 255))
    ("firebrick" . (178 34 34))
    ("floralwhite" . (255 250 240))
    ("forestgreen" . (34 139 34))
    ("fuchsia" . (255 0 255))
    ("gainsboro" . (220 220 220))
    ("ghostwhite" . (248 248 255))
    ("gold" . (255 215 0))
    ("goldenrod" . (218 165 32))
    ("gray" . (128 128 128))
    ("grey" . (128 128 128))
    ("green" . (0 128 0))
    ("greenyellow" . (173 255 47))
    ("honeydew" . (240 255 240))
    ("hotpink" . (255 105 180))
    ("indianred" . (205 92 92))
    ("indigo" . (75 0 130))
    ("ivory" . (255 255 240))
    ("khaki" . (240 230 140))
    ("lavender" . (230 230 250))
    ("lavenderblush" . (255 240 245))
    ("lawngreen" . (124 252 0))
    ("lemonchiffon" . (255 250 205))
    ("lightblue" . (173 216 230))
    ("lightcoral" . (240 128 128))
    ("lightcyan" . (224 255 255))
    ("lightgoldenrodyellow" . (250 250 210))
    ("lightgray" . (211 211 211))
    ("lightgreen" . (144 238 144))
    ("lightgrey" . (211 211 211))
    ("lightpink" . (255 182 193))
    ("lightsalmon" . (255 160 122))
    ("lightseagreen" . (32 178 170))
    ("lightskyblue" . (135 206 250))
    ("lightslategray" . (119 136 153))
    ("lightslategrey" . (119 136 153))
    ("lightsteelblue" . (176 196 222))
    ("lightyellow" . (255 255 224))
    ("lime" . (0 255 0))
    ("limegreen" . (50 205 50))
    ("linen" . (250 240 230))
    ("magenta" . (255 0 255))
    ("maroon" . (128 0 0))
    ("mediumaquamarine" . (102 205 170))
    ("mediumblue" . (0 0 205))
    ("mediumorchid" . (186 85 211))
    ("mediumpurple" . (147 112 219))
    ("mediumseagreen" . (60 179 113))
    ("mediumslateblue" . (123 104 238))
    ("mediumspringgreen" . (0 250 154))
    ("mediumturquoise" . (72 209 204))
    ("mediumvioletred" . (199 21 133))
    ("midnightblue" . (25 25 112))
    ("mintcream" . (245 255 250))
    ("mistyrose" . (255 228 225))
    ("moccasin" . (255 228 181))
    ("navajowhite" . (255 222 173))
    ("navy" . (0 0 128))
    ("oldlace" . (253 245 230))
    ("olive" . (128 128 0))
    ("olivedrab" . (107 142 35))
    ("orange" . (255 165 0))
    ("orangered" . (255 69 0))
    ("orchid" . (218 112 214))
    ("palegoldenrod" . (238 232 170))
    ("palegreen" . (152 251 152))
    ("paleturquoise" . (175 238 238))
    ("palevioletred" . (219 112 147))
    ("papayawhip" . (255 239 213))
    ("peachpuff" . (255 218 185))
    ("peru" . (205 133 63))
    ("pink" . (255 192 203))
    ("plum" . (221 160 221))
    ("powderblue" . (176 224 230))
    ("purple" . (128 0 128))
    ("red" . (255 0 0))
    ("rosybrown" . (188 143 143))
    ("royalblue" . (65 105 225))
    ("saddlebrown" . (139 69 19))
    ("salmon" . (250 128 114))
    ("sandybrown" . (244 164 96))
    ("seagreen" . (46 139 87))
    ("seashell" . (255 245 238))
    ("sienna" . (160 82 45))
    ("silver" . (192 192 192))
    ("skyblue" . (135 206 235))
    ("slateblue" . (106 90 205))
    ("slategray" . (112 128 144))
    ("slategrey" . (112 128 144))
    ("snow" . (255 250 250))
    ("springgreen" . (0 255 127))
    ("steelblue" . (70 130 180))
    ("tan" . (210 180 140))
    ("teal" . (0 128 128))
    ("thistle" . (216 191 216))
    ("tomato" . (255 99 71))
    ("turquoise" . (64 224 208))
    ("violet" . (238 130 238))
    ("wheat" . (245 222 179))
    ("white" . (255 255 255))
    ("whitesmoke" . (245 245 245))
    ("yellow" . (255 255 0))
    ("yellowgreen" . (154 205 50))))


(defun parse-hex-color (string)
  "Parse a CSS-style hexadecimal color string"
  (cond
    ((= 7 (length string))
     (list (or (parse-integer string :start 1 :end 3 :radix 16 :junk-allowed t) 0)
           (or (parse-integer string :start 3 :end 5 :radix 16 :junk-allowed t) 0)
           (or (parse-integer string :start 5 :end 7 :radix 16 :junk-allowed t) 0)))
    ((= 4 (length string))
     (labels ((extend (x) (logior (ash x 4) (if (zerop (logand x 1)) 0 #xF)))
              (parse (idx)
                (extend (or (parse-integer string :start idx :end (1+ idx)
                                           :radix 16 :junk-allowed t) 0))))
       (list (parse 1) (parse 2) (parse 3) )))
    (t '(0 0 0))))

(defun parse-color (string)
  "Parse an SVG/CSS-style color, which may be a named or hex color."
  (setf string (trim string))
  (cond
    ((zerop (length string)) nil)
    ((char= #\# (char string 0))
     (parse-hex-color string))
    (t (cdr (assoc string *svg-colors* :test #'string-equal)))))

(loop for (name color) in '(("#000000" (0 0 0))
                            ("#123456" (#x12 #x34 #x56))
                            ("#000"    (0 0 0))
                            ("#fff"    (255 255 255))
                            ("#246"    (32 64 96))
                            ("salmon"  (250 128 114)))
      collect (assert (equalp color (parse-color name))))

(defun color-to-float (components)
  (and components (mapcar (lambda (x) (/ x 255.0)) components)))

